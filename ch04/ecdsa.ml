open Unsigned.UInt32
open Ecc
open Dsa

(*
let curve_small = {
  a = Z.of_int 2;
  b = Z.of_int 2;
  p = Z.of_int 17;
  g = Some {x = Z.of_int 5; y = Z.one};
  n = Z.of_int 19;
  h = Z.one
}
*)

let k_list = [
  0x9E; 0x56; 0xF5; 0x09; 0x19; 0x67; 0x84; 0xD9; 0x63; 0xD1; 0xC0;
  0xA4; 0x01; 0x51; 0x0E; 0xE7; 0xAD; 0xA3; 0xDC; 0xC5; 0xDE; 0xE0;
  0x4B; 0x15; 0x4B; 0xF6; 0x1A; 0xF1; 0xD5; 0xA6; 0xDE; 0xCE
]

let ecdsa_sign (params: elliptic_curve) (private_key: Z.t) (hash: t array) (hash_len: int) (signature: dsa_signature ref) : unit =
  let n_size = size params.n in
  let k = list_to_z k_list in
  let kg_x = match (multiply_point params.g k params.a params.p) with 
            | Some pp -> pp.x
            | None -> Z.zero
  in
  let r = Z.erem kg_x params.n in
  let z = load_huge Digest.(hash_to_bytes hash (if (hash_len * 4) < n_size then hash_len else n_size / 4) Big) in
  let s = Z.erem (Z.mul (Z.add z (Z.mul r private_key)) (Z.invert k params.n)) params.n in
  signature := {r = r; s = s}

let ecdsa_verify (params: elliptic_curve) (public_key: ec_point) (hash: t array) (hash_len: int) (signature: dsa_signature) : bool =
  let n_size = size params.n in
  let w = Z.invert signature.s params.n in
  let z = load_huge Digest.(hash_to_bytes hash (if (hash_len * 4) < n_size then hash_len else n_size / 4) Big) in
  let u1 = Z.erem (Z.mul z w) params.n in
  let u2 = Z.erem (Z.mul signature.r w) params.n in
  let p_ = add_points (multiply_point params.g u1 params.a params.p) (multiply_point public_key u2 params.a params.p) params.a params.p in
  match p_ with
  | Some p -> Z.equal (Z.erem p.x params.n) signature.r
  | None -> Z.equal signature.r Z.zero


let p_list = [
  0xFF; 0xFF; 0xFF; 0xFF; 0x00; 0x00; 0x00; 0x01; 0x00; 0x00; 0x00; 0x00; 0x00;
  0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF;
  0xFF; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF
]

let b_list = [
  0x5A; 0xC6; 0x35; 0xD8; 0xAA; 0x3A; 0x93; 0xE7; 0xB3; 0xEB; 0xBD; 0x55; 0x76;
  0x98; 0x86; 0xBC; 0x65; 0x1D; 0x06; 0xB0; 0xCC; 0x53; 0xB0; 0xF6; 0x3B; 0xCE;
  0x3C; 0x3E; 0x27; 0xD2; 0x60; 0x4B
]

let n_list = [
  0xFF; 0xFF; 0xFF; 0xFF; 0x00; 0x00; 0x00; 0x00; 0xFF; 0xFF; 0xFF; 0xFF; 0xFF;
  0xFF; 0xFF; 0xFF; 0xBC; 0xE6; 0xFA; 0xAD; 0xA7; 0x17; 0x9E; 0x84; 0xF3; 0xB9;
  0xCA; 0xC2; 0xFC; 0x63; 0x25; 0x51
]

let gx_list = [
  0x6B; 0x17; 0xD1; 0xF2; 0xE1; 0x2C; 0x42; 0x47; 0xF8; 0xBC; 0xE6; 0xE5; 0x63;
  0xA4; 0x40; 0xF2; 0x77; 0x03; 0x7D; 0x81; 0x2D; 0xEB; 0x33; 0xA0; 0xF4; 0xA1;
  0x39; 0x45; 0xD8; 0x98; 0xC2; 0x96
]

let gy_list = [
  0x4F; 0xE3; 0x42; 0xE2; 0xFE; 0x1A; 0x7F; 0x9B; 0x8E; 0xE7; 0xEB; 0x4A; 0x7C;
  0x0F; 0x9E; 0x16; 0x2B; 0xCE; 0x33; 0x57; 0x6B; 0x31; 0x5E; 0xCE; 0xCB; 0xB6;
  0x40; 0x68; 0x37; 0xBF; 0x51; 0xF5
]

(* NIST P-256 *)
let curve = {
  p = list_to_z p_list;
  b = list_to_z b_list;
  n = list_to_z n_list;
  g = Some { x = list_to_z gx_list; y = list_to_z gy_list }; 
  a = Z.sub Z.zero (Z.of_int 3);
  h = Z.zero (* not relevant for ECDSA *)
}

let d_list = [
  0xDC; 0x51; 0xD3; 0x86; 0x6A; 0x15; 0xBA; 0xCD; 0xE3;
  0x3D; 0x96; 0xF9; 0x92; 0xFC; 0xA9; 0x9D; 0xA7; 0xE6; 0xEF; 0x09; 0x34; 0xE7;
  0x09; 0x75; 0x59; 0xC2; 0x7F; 0x16; 0x14; 0xC8; 0x8A; 0x7F
]

let () =
  let d = list_to_z d_list in
  let q = multiply_point curve.g d curve.a curve.p in
  let msg = Byte.of_string "abc123" in
  let signature = ref { r = Z.zero; s = Z.zero } in
  let digest = ref Digest.new_sha1_digest in
  digest := Digest.update_digest !digest msg (Byte.length msg);
  digest := Digest.finalize_digest !digest;
  ecdsa_sign curve d !digest.hash !digest.hash_len signature;
  Byte.print_byte (Byte.of_string (Z.to_bits !signature.r));
  Byte.print_byte (Byte.of_string (Z.to_bits !signature.s));
  if (ecdsa_verify curve q !digest.hash !digest.hash_len !signature) then
    print_string "verified ..\n"
  else print_string "wrong sig ..\n"
